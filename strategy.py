import tensorflow as tf
tf.logging.set_verbosity(tf.logging.ERROR)
import model_loader
import os
import pandas as pd
import pickle
import numpy as np
from auxiliary import *
import numpy as np
import bigfloat as bg
from numpy.linalg import norm
import math
import sys
if not sys.warnoptions:
    import warnings
    warnings.simplefilter("ignore")

import tensorflow as tf
import numpy as np

from kj.data_preprocessor import DataPreprocessor
from kj.input_helper import InputHelper
import kj.predict

os.chdir('.')
bar_length = 10
time_steps=30
input_size=2
output_size = 1
num_layers=3
hidden=32
assets = [1,2,3]
times = [1,1,1,1]

regression = False


module_path = os.path.dirname(__file__)

mean_std = np.load(module_path +"/kj/save/mean-std.npy")
mean, std = mean_std[0], mean_std[1]

input_helper = InputHelper()

models = {}
for asset in assets:
    models[asset] = kj.predict.load(asset)

# Bayesian regression model learnt parameters
w_BTC = np.array([0.0, 1.515611669307353e-06, -3.0540922787140065e-05, 1.2362617671752183e-05])
w_BCH = np.array([0.0, 3.024386958586751e-05, 4.4473320989700415e-06, -1.1413577268887765e-05])
w_ETH = ([0.0, -1.561997757956787e-06, -2.0347123272206327e-06, -9.795150686504873e-07])
w_LTC = np.array([0.0, -1.561997757956787e-06, -2.0347123272206327e-06, -9.795150686504873e-07])
# asset_index_BTC
asset_index_BCH = 0
asset_index_BTC = 1
asset_index_ETH = 2
asset_index_LTC = 3
time_sieries_length = 720
time_interval = 1 # 1 minute
num = 0
s1_BTC = pd.read_csv('BTCs1_no_ask.csv').values
s2_BTC = pd.read_csv('BTCs2_no_ask.csv').values
s3_BTC = pd.read_csv('BTCs3_no_ask.csv').values

s1_BCH = pd.read_csv('BCHs1_no_ask.csv').values
s2_BCH = pd.read_csv('BCHs2_no_ask.csv').values
s3_BCH = pd.read_csv('BCHs3_no_ask.csv').values

s1_ETH = pd.read_csv('ETHs1_no_ask.csv').values
s2_ETH= pd.read_csv('ETHs2_no_ask.csv').values
s3_ETH = pd.read_csv('ETHs3_no_ask.csv').values

s1_LTC = pd.read_csv('LTCs1_no_ask.csv').values
s2_LTC = pd.read_csv('LTCs2_no_ask.csv').values
s3_LTC = pd.read_csv('LTCs3_no_ask.csv').values

# pre-load model to speed up 
gru_models = {}
for asset in assets:
    gru_models[asset] = model_loader.load(asset)

upper_bound = [516.77,6546.40,224.39,58.64]
lower_bound = [486.58,6481.08,218.36,56.93]

def predict_dpi(x, s):
    """Predict the average price change Δp_i, 1 <= i <= 3.

    Args:
        x: A numpy array of floats representing previous prices.
        s: A 2-dimensional numpy array generated by choose_effective_centers().

    Returns:
        A big float representing average price change Δp_i.
    """
    num = 0
    den = 0
    for i in range(len(s)):
        y_i = s[i, len(x)]
        x_i = s[i, :len(x)]
        exp = bg.exp(-0.25 * norm(x - x_i) ** 2)
        num += y_i * exp
        den += exp
    return num / den

def predict_dps(prices, s1, s2, s3, w, t=0.001):
    """Predict average price changes (final estimations Δp) over the third
       time period.

    Args:
        prices: A numpy array of floats representing prices over the third time
            period.
        s1: A 2-dimensional numpy array generated by choose_effective_centers()
        s2: A 2-dimensional numpy array generated by choose_effective_centers().
        s3: A 2-dimensional numpy array generated by choose_effective_centers().
        w: A tuple (w0, w1, w2, w3) generated by model.

    Returns:
        A numpy array of floats. Each array element represents the final
        estimation Δp.
    """
    #dps = []
    w0, w1, w2, w3 = w
    ts1 = prices[-180:]
    ts2 = prices[-360:]
    ts3 = prices[0:720]
    dp1 = predict_dpi(ts1, s1)
    dp2 = predict_dpi(ts2, s2)
    dp3 = predict_dpi(ts3, s3)
    if(math.isnan(dp1)):
        dp1 = 0
    if(math.isnan(dp2)):
        dp2 = 0
    if(math.isnan(dp3)):
        dp3 = 0
    dp = w0 + w1 * dp1 + w2 * dp2 + w3 * dp3
    position = 0
    if(dp > t):
        position = 1
    elif(dp < -t):
        position = -1
    else:
        position = 0
    return position, dp


#transfer the ouput
def trans_2(num):
    r = num
    if num >= 1.8:
        return  1.025
    elif num >= 0.2:
        return 1
    else:
        return  0.975




def handle_bar(counter,  # a counter for number of minute bars that have already been tested
               time,  # current time in string format such as "2018-07-30 00:30:00"
               data,  # data for current minute bar (in format 2)
               init_cash,  # your initial cash, a constant
               transaction,  # transaction ratio, a constant
               cash_balance,  # your cash balance at current minute
               crypto_balance,  # your crpyto currency balance at current minute
               total_balance,  # your total balance at current minute
               position_current,  # your position for 4 crypto currencies at this minute
               memory  # a class, containing the information you saved so far
               ):
    # Pattern for short signal:
    # if next minute price is larger than the upper bounder, then short certain amount

    # Pattern for short signal:
    # if next minute price is lower than the upper bounder, then long certain amount

    # use rnn based model to predict the next time price
    # input of the model is the normaled price and the volume
    # the output put of model is one value which is assumed to return 0,1,2 which stands for lower <-5%,same -5%-5%,larger >5%

    # if cash balance is lower than some value, then manually let the next position to be 0

    # Get position of last minute

    position_new = position_current.copy()
    if (counter == 0):
        memory.data_save_wzc = {}
        memory.data_wzc = {}
        memory.transaction_wzc = {}
        memory.last_wzc = {}
        memory.next_wzc = {}
        memory.pred_seq_wzc ={}
        memory.kj_data_save = []
        memory.kj_bar_save = []
        memory.data_save = pd.DataFrame(columns=['close_BTC', 'close_BCH', 'close_LTC', 'close_ETH'])
        for asset_index in range(4):
            memory.data_save_wzc[asset_index] = pd.DataFrame(columns = ['close', 'high', 'low', 'open', 'volume'])
            memory.data_wzc[asset_index] = []
            memory.transaction_wzc[asset_index] = 0
            memory.last_wzc[asset_index] = 0
            memory.next_wzc[asset_index] = 0
            memory.pred_seq_wzc[asset_index] =0

    memory.kj_data_save.append(data[:, :])

    if (counter + 1) % bar_length == 0:
        #kuojian
        bar = DataPreprocessor().preprocess(np.asarray(memory.kj_data_save), bar_length)
        bar = DataPreprocessor().select_features(bar)
        memory.kj_bar_save.append(bar.reshape(bar.shape[1:]))
        memory.kj_data_save.clear()
        if len(memory.kj_bar_save) == time_steps + 1:
            for asset in assets:
                x, y = input_helper.generate_dataset(np.asarray(memory.kj_bar_save), [asset], time_steps, regression)
                shape = x.shape
                x = x.reshape(-1, shape[-1])
                x = (x - mean) / std
                x = x.reshape(shape)
                pred = kj.predict.predict(models[asset][1], models[asset][2], x, y)
                if cash_balance > 16000:
                    if pred > 0.55:
                        position_new[asset] += 0.5
                    elif pred > 0.7:
                        position_new[asset] += 1
                    elif pred > 0.85:
                        position_new[asset] += 1
                if position_current[asset] > 0:
                    if pred < 0.45:
                        position_new[asset] -= 0.5
                    elif pred < 0.3:
                        position_new[asset] -= 1
                    elif pred < 0.15:
                        position_new[asset] = 0
            memory.kj_bar_save.pop(0)


        #zhaocai
        memory.data_save.loc[int((counter + 1) / time_interval) - 1] = \
            data[asset_index_BTC,][0], 0, data[asset_index_LTC,][0], data[asset_index_ETH,][0]

        if ((counter + 1) > time_sieries_length * time_interval) :
            memory.data_save.loc[int((counter + 1) / time_interval) - 1] = \
                data[asset_index_BTC,][0], data[asset_index_BCH,][0], data[asset_index_LTC,][0], data[asset_index_ETH,][0]
            bar_BTC = generate_series(memory.data_save['close_BTC'][-time_sieries_length:], time_sieries_length) # pandas dataframe
            bar_LTC = generate_series(memory.data_save['close_LTC'][-time_sieries_length:], time_sieries_length) # pandas dataframe
            bar_ETH = generate_series(memory.data_save['close_ETH'][-time_sieries_length:], time_sieries_length) # pandas dataframe
            pred_vaule_BTC, dp_BTC= predict_dps((np.array(bar_BTC.tail(1)))[0], s1_BTC, s2_BTC, s3_BTC, w_BTC, t=0.000001)
            pred_vaule_LTC, dp_LTC= predict_dps((np.array(bar_LTC.tail(1)))[0], s1_LTC, s2_LTC, s3_LTC, w_LTC, t=0.000001)
            pred_vaule_ETH, dp_ETH = predict_dps((np.array(bar_ETH.tail(1)))[0], s1_ETH, s2_ETH, s3_ETH, w_ETH, t=0.000001)
            if cash_balance < 16000:
                if pred_vaule_BTC == 1:
                    pred_vaule_BTC = 0
                if pred_vaule_LTC == 1:
                    pred_vaule_LTC = 0
                if pred_vaule_ETH == 1:
                    pred_vaule_ETH = 0
            position_new[asset_index_BTC] += pred_vaule_BTC
            position_new[asset_index_LTC] += pred_vaule_LTC
            position_new[asset_index_ETH] += pred_vaule_ETH

        for asset_index in assets:
            memory.data_save_wzc[asset_index].loc[bar_length - 1] = data[asset_index,]
            segment = generate_seg_wzc(memory.data_save_wzc[asset_index]) # pandas dataframe
            memory.data_wzc[asset_index].append(segment) 
                
        #zhicong
        if len(memory.data_wzc[asset_index]) == time_steps:
             for asset_index in assets:
                if 1:
                   
                    memory.last_wzc[asset_index] = memory.data_wzc[asset_index][-1][0]
                    inputs = generate_bar2_wzc(memory.data_wzc[asset_index])
                    #print(inputs)
                    x = np.array(inputs).reshape(1,time_steps,input_size)   
                    predict = model_loader.predict(gru_models[asset_index][1],gru_models[asset_index][2],x)
                    
                    memory.transaction_wzc[asset_index] = trans_2(predict)
                    memory.pred_seq_wzc[asset_index] = 0
                    if memory.last_wzc[asset_index] * memory.transaction_wzc[asset_index] >= upper_bound[asset_index]:
                        position_new[asset_index]  = - 1 * times[asset_index]
                    elif memory.last_wzc[asset_index] * memory.transaction_wzc[asset_index]>= lower_bound[asset_index]:
                        position_new[asset_index]  = 0
                    elif memory.last_wzc[asset_index] * memory.transaction_wzc[asset_index] < lower_bound[asset_index]:
                        position_new[asset_index]  = 1 * times[asset_index]
                   
                    
                memory.data_wzc[asset_index] = memory.data_wzc[asset_index][1:]
    else:
        for asset_index in assets:
            memory.data_save_wzc[asset_index].loc[(counter + 1) % bar_length - 1] = data[asset_index,]

        memory.data_save.loc[int((counter + 1) / time_interval) - 1] = \
                data[asset_index_BTC,][0], 0, data[asset_index_LTC,][0], data[asset_index_ETH,][0]


    # ensamble strategy
    for i in assets:
        if position_new[i] >= 1 and cash_balance > 16000:
            position_new[i] = 1
        elif position_new[i] <= -1:
            position_new[i] = -1
        else:
            position_new[i] = 0

    # End of strategy
    return position_new, memory
